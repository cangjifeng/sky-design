/**
 * 代理模式 : 代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用. <br>
 *<p>-------------------------------------------------------------------------
 * <ol>使用代理模式原因和场景，以及解决的问题
 * <li>隔离,中介隔离作用：<br>
 *     在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和<br>
 *     委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。
 *     </li>
 * <li>增强,开闭原则,增强功能<br>
 *     给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，<br>
 *     符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，<br>
 *     以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，<br>
 *     来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一<br>
 *     些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没<br>
 *    必要打开已经封装好的委托类</li>
 * </ol>
 *
 * <p>-------------------------------------------------------------------------
 * <ol>代理模式分类
 *     <li>静态代理</li>
 *     <li>动态代理,多种实现<br>
 *     基于JDK实现<br>
 *     基于cglib实现
 *     </li>
 * </ol>
 */
package org.jerfan.design.pattern.proxy;

